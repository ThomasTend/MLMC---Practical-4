#!/usr/bin/env python

import matplotlib
import matplotlib.pyplot as plt
import numpy
import os
from cycler import cycler

# Set matplotlib defaults to agree with MATLAB code
plt.rc("legend", framealpha=None)
plt.rc("legend", edgecolor='black')
plt.rc("font", family="serif")
# Following option for TeX text seems to not work with EPS figures?
#plt.rc("text", usetex=True)

# NOTE: set clip_on=False in plotting to get consistent style with MATLAB

def mlmc_plot(filename, nvert, error_bars=False):
    """
    Utility to generate MLMC diagnostic plots based on
    input text file generated by MLMC driver code mlmc_test.

    mlmc_plot(filename, nvert, error_bars=False)

    Inputs:
      filename: string, (base of) filename with output from mlmc_test routine
      nvert   : int, number of vertical plots <= 3
                    nvert == 1   generates fig1: (1),(2) fig2: (5),(6)
                    nvert == 2   generates fig1: (1),(2),(5),(6)
                    nvert == 3   generates fig1: (1)-(6)
      error_bars: bool, flag to add error bars in plots of level differences

    Outputs:
      Matplotlib figure(s) for
        Convergence tests
        (1) Var[P_l - P_{l-1}] per level
        (2) E[|P_l - P_{l-1}|] per level
        (3) cost per level
        (4) kurtosis per level
        Complexity tests
        (5) number of samples per level
        (6) normalised cost per accuracy target
    """

    #
    # read in data
    #

    # Default file extension is .txt if none supplied
    if not os.path.splitext(filename)[1]:
        file = open(filename + ".txt", "r")
    else:
        file = open(filename, "r")

    # Declare lists for data
    del1 = []
    del2 = []
    var1 = []
    var2 = []
    kur1 = []
    chk1 = []
    cost = []
    l    = []

    epss = []
    mlmc_cost = []
    std_cost = []
    Ns = []
    ls = []

    # Default values for number of samples and file_version
    N = 0
    file_version = 0.8

    complexity_flag = False # first read convergence tests rather than complexity tests
    for line in file:
        # Recognise file version line from the fact that it starts with '*** MLMC file version'
        if line[0:21] == '*** MLMC file version':
            file_version = float(line[23:30])
        # Recognise number of samples line from the fact that it starts with '*** using'
        if line[0:9] == '*** using':
            N = int(line[14:20])

        # Recognise whether we should switch to reading complexity tests
        if line[0:19] == '*** MLMC complexity':
            complexity_flag = True # now start to read complexity tests

        # Recognise MLMC complexity test lines from the fact that line[0] is an integer
        # Also need complexity_flag == True because line[0] is an integer also identifies
        # the convergence test lines
        if '0' <= line[0] <= '9' and complexity_flag:
            splitline = [float(x) for x in line.split()]
            epss.append(splitline[0])
            mlmc_cost.append(splitline[2])
            std_cost.append(splitline[3])
            Ns.append(splitline[5:])
            ls.append(list(range(0,len(splitline[5:]))))

        # Recognise convergence test lines from the fact that line[1] is an integer
        # and possibly also line[0] (or line[0] is whitespace)
        if (line[0] == ' ' or '0' <= line[0] <= '9') and '0' <= line[1] <= '9':
            splitline = [float(x) for x in line.split()]
            l.append(splitline[0])
            del1.append(splitline[1])
            del2.append(splitline[2])
            var1.append(splitline[3])
            var2.append(splitline[4])
            kur1.append(splitline[5])
            chk1.append(splitline[6])
            cost.append(splitline[7])
            continue

    if (file_version < 0.9):
        if (error_bars):
            raise Warning("Cannot plot error bars -- no value of N in file")
            error_bars = False

    # Compute variance of variance ( correct up to O(1/N) )
    if (error_bars):
        vvr1 = [ v**2 * (kur - 1.0) for (v, kur) in zip(var1,kur1)]

    #
    # plot figures
    #

    # Fudge to get comparable size to default MATLAB fig size
    width_MATLAB = 0.9*8; height_MATLAB = 0.9*6.5;
    plt.figure(figsize=([width_MATLAB, height_MATLAB*0.75*nvert]))

    plt.rc('axes', prop_cycle=(cycler('color', ['k']) *
                               cycler('linestyle', ['--', ':']) *
                               cycler('marker', ['*'])))

    # Var[P_l - P_{l-1}] per level
    plt.subplot(nvert, 2, 1)
    plt.plot(l,     numpy.log2(var2),     label=r'$P_\ell$', clip_on=False)
    plt.plot(l[1:], numpy.log2(var1[1:]), label=r'$P_\ell - P_{\ell-1}$', clip_on=False)
    plt.xlabel('level $\ell$')
    plt.ylabel(r'$\mathrm{log}_2(\mathrm{variance})$')
    plt.legend(loc='lower left', fontsize='medium')
    axis = plt.axis(); plt.axis([0, max(l), axis[2], axis[3]])

    if (error_bars):
        plt.plot(l[1:], numpy.log2(numpy.maximum(numpy.abs(numpy.array(var1[1:]) -
            3.0*numpy.sqrt(vvr1[1:])/numpy.sqrt(N)), 1e-10)), '-r.', clip_on=False)
        plt.plot(l[1:], numpy.log2(              numpy.abs(numpy.array(var1[1:]) +
            3.0*numpy.sqrt(vvr1[1:])/numpy.sqrt(N))        ), '-r.', clip_on=False)

    # E[|P_l - P_{l-1}|] per level
    plt.subplot(nvert, 2, 2)
    plt.plot(l,     numpy.log2(numpy.abs(del2)),     label=r'$P_\ell$', clip_on=False)
    plt.plot(l[1:], numpy.log2(numpy.abs(del1[1:])), label=r'$P_\ell - P_{\ell-1}$', clip_on=False)
    plt.xlabel('level $\ell$')
    plt.ylabel(r'$\mathrm{log}_2(|\mathrm{mean}|)$')
    plt.legend(loc='lower left', fontsize='medium')
    axis = plt.axis(); plt.axis([0, max(l), axis[2], axis[3]])

    if (error_bars):
        plt.plot(l[1:], numpy.log2(numpy.maximum(numpy.abs(numpy.array(del1[1:]) -
            3.0*numpy.sqrt(var1[1:])/numpy.sqrt(N)), 1e-10)), '-r.', clip_on=False)
        plt.plot(l[1:], numpy.log2(              numpy.abs(numpy.array(del1[1:]) +
            3.0*numpy.sqrt(var1[1:])/numpy.sqrt(N))        ), '-r.', clip_on=False)

    if nvert == 3:
        # consistency check
#        plt.subplot(nvert, 2, 3)
#        plt.plot(l[1:], chk1[1:], '*--')
#        plt.xlabel('level $\ell$')
#        plt.ylabel(r'consistency check')
#        axis = plt.axis(); plt.axis([0, max(l), axis[2], axis[3]])

        # cost per level
        plt.subplot(nvert, 2, 3)
        plt.plot(l, numpy.log2(cost), '*--', clip_on=False)
        plt.xlabel('level $\ell$')
        plt.ylabel(r'$\log_2$ cost per sample')
        axis = plt.axis(); plt.axis([0, max(l), axis[2], axis[3]])

        # kurtosis per level
        plt.subplot(nvert, 2, 4)
        plt.plot(l[1:], kur1[1:], '*--', clip_on=False)
        plt.xlabel('level $\ell$')
        plt.ylabel(r'kurtosis')
        axis = plt.axis(); plt.axis([0, max(l), axis[2], axis[3]])

    if nvert == 1:
        # Fix subplot spacing
        plt.subplots_adjust(wspace=0.3)
        plt.subplots_adjust(hspace=0.4)
        plt.figure(figsize=(width_MATLAB, height_MATLAB*0.75*nvert))

    marker_styles = ['o', 'x', 'd', '*', 's']
    plt.rc('axes', prop_cycle=(cycler('color', ['k']) *
                               cycler('linestyle', ['--']) *
                               cycler('marker', marker_styles)))

    # number of samples per level
    plt.subplot(nvert, 2, 2*nvert-1)
    for (eps, ll, n) in zip(epss, ls, Ns):
        plt.semilogy(ll, n, label=eps, markerfacecolor='none', clip_on=False)
    plt.xlabel('level $\ell$')
    plt.ylabel('$N_\ell$')
    plt.legend(loc='upper right', frameon=True, fontsize='medium')
    axis = plt.axis(); plt.axis([0, max([max(x) for x in ls]), axis[2], axis[3]])


    plt.rc('axes', prop_cycle=(cycler('color', ['k']) *
                               cycler('linestyle', ['--', ':']) *
                               cycler('marker', ['*'])))

    # normalised cost for given accuracy
    eps = numpy.array(epss)
    std_cost = numpy.array(std_cost)
    mlmc_cost = numpy.array(mlmc_cost)
    I = numpy.argsort(eps)
    plt.subplot(nvert, 2, 2*nvert)
    plt.loglog(eps[I], eps[I]**2 * std_cost[I],  '*-',  label='Std MC', clip_on=False)
    plt.loglog(eps[I], eps[I]**2 * mlmc_cost[I], '*--', label='MLMC',   clip_on=False)
    plt.xlabel(r'accuracy $\varepsilon$')
    plt.ylabel(r'$\varepsilon^2$ cost')
    plt.legend(fontsize='medium')
    axis = plt.axis(); plt.axis([min(eps), max(eps), axis[2], axis[3]])

    # Fix subplot spacing
    plt.subplots_adjust(wspace=0.3)
    plt.subplots_adjust(hspace=0.4)

if __name__ == "__main__":
    import sys

    mlmc_plot(sys.argv[1], nvert=3)
    plt.savefig(sys.argv[1].replace(".txt", ".eps"))
